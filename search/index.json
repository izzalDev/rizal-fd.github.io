[{"content":"Pengantar Image enhancement atau peningkatan citra merupakan salah satu proses awal pengolahan citra (image processing) untuk mendapatkan citra yang hasilnya lebih sesuai dari citra asli untuk kepentingan tertentu. Tujuan yang spesifik sangatlah penting, karena berorientasi pada tujuan digunakannya suatu citra. Contohnya seperti dilakukannya peningkatan kualitas pada citra X-tray/Rontgen tentu saja metodenya akan berbeda dengan citra yang ditingkatkan untuk citra keperluan antariksa.\nMetode peningkatan citra digital dibagi menjadi dua jenis, yaitu metode domain spasial dan metode domain frekuensi. Istilah metode domain spasial mengacu pada bidang gambar dan pendekatan metode ini dilakukan dengan memanipulasi langsung pada nilai piksel citra. Sedangkan pada domain frekuensi dilakukan dengan menggunakan Transformasi Fourier, yaitu nilai matriks dari citra yang sebelumnya berada pada domain spasial diubah ke domain frekuensi. Pada artikel kali ini yang akan kita bahas adalah metode domain spasial. Dalam metode domain spasial sendiri terbagi menjadi dua yaitu point processing dan mask processing\nKonsep Point Processing Point Processing (Operasi Titik) yaitu metode peningakatan citra dimana untuk melakukannya tidak ada ketergantungan terhadap titik-titik/piksel yang ada disekelilingnya. Dalam kata lain piksel yang ada langsung diproses secara individu tanpa mempengaruhi piksel yang ada disekelilingnya. Beberapa metode point processing antara lain: Inversi Citra (Citra Negatif), peningkatan kecerahan, peregangan kontras, , pemotongan aras keabuan (Tresholding), dan Ekualisasi Histogram.\nCitra Negatif Operasi ini menghasilkan citra seperti pada film (negative) foto. Operasi ini mengubah piksel terang menjadi gelap dan sebaliknya. Sedangkan jika dilihat pada histogram operasi ini menghasilkan cerminan/kebalikan dari histogram citra awal. Operasi ini dilakukan dengan cara mengurangi nilai intensitas piksel dari intensitas maksimum piksel atau secara matematis dapat dituliskan sebagai berikut: $ f'_{(x,y)} = f _{max} - f _{(x,y)} $\nImplementasi pada python:\n# Import dependensi yang diperlukan terlebih dahulu import cv2 as cv import numpy as np import matplotlib.pyplot as plt # deklarasi fungsi pendukung def show (src, title=\u0026#39;\u0026#39;, size=(4,4), cmap=\u0026#39;gray\u0026#39;): # fungsi ini digunakan untuk menampilkan citra figure=plt.figure(figsize=size) plt.title(title) plt.imshow(img,cmap=cmap) plt.axis(\u0026#39;off\u0026#39;) # Membaca image menggunakan opencv img = cv.imread(\u0026#39;sample.jpg\u0026#39;,0) Dalam dependensi numpy terdapat operasi elementwise dimana secara otomatis numpy akan melakukan operasi secara otomatis terhadap element-element yang ada didalam matriks operasi ini dapat dilakukan dengan matriks yang dimensinya sama atau bisa juga dilakukan dengan skalar/konstanta\n# inversi citra inv = 255 - img show(img,\u0026#34;Original Image\u0026#34;) show(inv,\u0026#34;Negative Image\u0026#34;) plt.show    \nPeningkatan Kecerahan Peningkatan kecerahan (brightness) juga merupakan salah satu operasi dasar pada pengolahan citra. Peningkatan kecerahan dilakukan agar mendapatkan citra yang lebih terang. Untuk melakukan operasi peningkatan kecerahan pada citra dilakukan dengan cara melakukan penambahan nilai dari tiap-tiap piksel dengan suatu konstanta. Secara matematis dapat ditulis sebagai berikut : $ f'_{(x,y)} = f _{(x,y)} + \\beta $ . Dimana $\\beta$ adalah konstanta, jika bernilai positif maka kecerahan akan naik dan sebaliknya.\nImplementasi pada program :\noutput = img + 30 show(img,\u0026#34;Original Image\u0026#34;) show(output,\u0026#34;Brightness Adjustment Image\u0026#34;) plt.show()    \nPeregangan Kontras Pada suatu citra digital kontras merupakan distribusi warna terang dan gelap. Suatu citra dikatakan memiliki kontras yang rendah apabila jangkauan nilai pikselnya sempit. Sebaliknya, sebuah citra digital dinyatakan kontrasnya tinggi ketika jangkauan nilai pikselnya lebar.\n a) Low contras || b) High contras \nUntuk meningkatkan kontras suatu citra digital dapat dilakukan dengan cara mengalikan nilai tiap piksel dari citra dengan konstanta. Sebaliknya apabila ingin mengurangi citra maka dapat dilakukan dengan membagi nilai tiap piksel dengan konstanta. Secara matematis dapat ditulis sebagai berikut : $ f' _{(x,y)} = \\alpha f _{(x,y)} $ dimana $\\alpha$ adalah konstanta\nImplementasi dalam program.\noutput = 2 * img show(img,\u0026#34;Original Image\u0026#34;) show(output,\u0026#34;Contras Adjustment Image\u0026#34;) plt.show() Thresholding Thresholding atau pemotongan aras keabuan dapat dihasilkan dengan operasi berikut:\n$$ f' _{(x,y)} = \\begin{cases} \\begin{align*} 0 \u0026amp;, x \\le f_1 \\newline f _{(x,y)}\u0026amp;, f_1 \u0026lt; f _{(x,y)} \u0026lt; f_2 \\newline 255 \u0026amp;, x \\ge f_2 \\end{align*} \\end{cases} $$\nnilai $f'$ dinolkan atau dipotong habis untuk nilai asli dari 0 hingga $f_1$ karena dianggap tidak mengandung informasi penting. Berlaku juga untuk nilai piksel dari $f_2$ keatas, yang mungkin hanya mengandung derau(noise).\nImplementasi pada program.\ndef thres (src,f1,f2): j,i = src.shape result = np.zeros((j,i)) for x in range (i): for y in range (j): if src[x,y] \u0026lt;= f1: result[x,y] = 0 elif src[x,y] \u0026lt; f2: result[x,y] = src[x,y] else : result[x,y]= 255 return result output = thres(img,100,150) show(img, \u0026#34;Original Image\u0026#34;,(4,4)) show(output, \u0026#34;Threshold Image\u0026#34;,(4,4)) plt.show()    \nReferensi\nGonzalez, Rafael C. 2001. Digital Image Processing Second Edition. Tom Robbins.\nEddine ALAA, Nour, dan Ismail Zine El Abidne. 2021. Introduction to Image Processing with Python. Cadi Ayyad University.\nKadir, Abdul, dan Adhi Susanto. 2012. Pengolahan Citra Teori dan Aplikasi. Yogyakarta.\n","date":"2021-10-23T18:21:31+07:00","image":"https://rizal-fd.github.io/p/image-enhancement-point-processing/background_hu8bb55b9ae64f18b41e2e1aae1cb4ddde_390648_120x120_fill_q75_box_smart1.jpeg","permalink":"https://rizal-fd.github.io/p/image-enhancement-point-processing/","title":"Image Enhancement - Point Processing"},{"content":"Apa itu image compression? Sering kali dalam kehidupan sehari-hari kita menggunakan citra/gambar baik itu untuk keperluan akademik maupun sosial media namun apakah kita tahu bahwa sebenarnya citra digital yang kita gunakan sebenarnya merupakan interpretasi dari matriks, ya matriks yang sering kita pelajari dulu ketika di SMA. Sebuah citra digital merupakan matriks dua hingga tiga dimensi. Untuk citra hitam putih \u0026 grayscale sendiri tersusun dari matriks dua dimensi sedangkan citra berwarna (RGB) tersusun dari matriks tiga dimensi. Tahukan kamu bahwa hasil citra pada kamera sebenarnya berformat RAW?, citra berformat RAW ini memiliki ukuran yang besar sehingga perlu dimampatkan (kompres). Pemampatan ini bertujuan untuk mengurangi ukuran file agar lebih efisien. Secara garis besar ada dua teknik kompresi pada citra, yaitu lossless dan lossy. Pada teknik kompresi lossless citra akan direkonstruksi secara sempurna tanpa mengurangi kualitas citra sedangkan teknik kompresi lossy compression atau juga disebut irreversible compression merupakan teknik kompresi yang menggunakan perkiraan yang tidak tepak dan membuang sebagian data untuk mewakili konten.   Ilustrasi citra digital \nKonsep RLE (Run Length Encoding) RLE (Run Length Encoding) merupakan salah satu teknik kompresi lossless yang paling mudah dipraktikkan. Konsep RLE Compression adalah dengan memeriksa pengulangan nilai pixel yang terjadi berturut-turut. Algoritma ini dapat bekerja dengan efisien pada citra biner. Mari kita ambil contoh citra [ 0 1 1 1 1 1 0 0 0 0 0 0 1 1 1 0 0 0 1 1 1 ] memiiki 21 pixel dan terdiri dari binary. Untuk menggunakan algoritma RLE langkah - langkah yang perlu kita lakukan sebagai berikut.\n Langkah awal, pointer saat ini ada pada pixel pertama yaitu 0 . Kemudian kita kompresi menjadi [01] yang artinya 0 diulang sebanyak 1 kali. Selanjutnya bernilai 1 yang diulang sebanyak 5 kali setelah itu kita gabungkan pada hasil kompresi sebelumnya menjadi [01 15]. Kemudian bernilai 0 yang diulang sebanyak 6 kali dan kita gabungkan dengan hasil kompresi sebelumnya menjadi [01 15 06]. Ulang langkah sebelumnya sampai dengan pixel terakhir. Hasil RLE [01 15 06 13 03 13] Citra sebelumnya memiliki 21 nilai sekarang setelah dikompress menjadi 6 nilai.  Sekarang untuk mendekompresi atau mengembalikan nilai semula yaitu,\n Nilai awal yaitu 01, yang berarti 0 diulang sebanyak satu kali. Menghasilkan [1]. Selanjutnya yaitu 15. Kita lakukan seperti sebelumnya, dan digabung dengan hasil sebelumnya menghasilkan [0 1 1 1 1 1]. Dan seterusnya.    Ilustrasi RLE \nImplementasi pada Python Persiapan Awal Import dependensi dan deklarasi fungsi pendukung yang akan digunakan.\nimport numpy as np import cv2 import matplotlib.pyplot as plt import sys import os # Fungsi untuk menampilkan citra def show(img, figsize=(10, 10), title=\u0026#34;Image\u0026#34;, cmap=\u0026#39;RGB\u0026#39;): figure=plt.figure(figsize=figsize) plt.imshow(img,cmap=cmap) plt.axis(\u0026#39;off\u0026#39;) plt.show()  contoh citra \nMari kita cari tahu ukuran citra diatas dengan python.\n# fungsi untuk menampilkan ukuran file def get_size(filename=\u0026#34;lena.jpg\u0026#34;): stat = os.stat(filename) size=stat.st_size print(size/1024,\u0026#39;KB\u0026#39;) return size get_size() 7.818359375 KB Diketahui bahwa contoh citra memiliki ukuran 7,8KB\nFungsi Encoding Sekarang kita lakukan RLE compression pada contah citra lena dan kita save kedalam file.\n# read graysclae img def RLE_encoding(img, bits=8, binary=True): \u0026#34;\u0026#34;\u0026#34; img: Grayscale img. bits: what will be the maximum run length? 2^bits \u0026#34;\u0026#34;\u0026#34; if binary: ret,img = cv.threshold(img,127,255,cv.THRESH_BINARY+cv.THRESH_OTSU) encoded = [] shape=img.shape count = 0 prev = None fimg = img.flatten() th=127 for pixel in fimg: if binary: if pixel\u0026lt;th: pixel=0 else: pixel=1 if prev==None: prev = pixel count+=1 else: if prev!=pixel: encoded.append((count, prev)) prev=pixel count=1 else: if count\u0026lt;(2**bits)-1: count+=1 else: encoded.append((count, prev)) prev=pixel count=1 encoded.append((count, prev)) return np.array(encoded) # read image as grayscale img = cv.imread(\u0026#39;lena.jpg\u0026#39;,0) encoded = RLE_encoding(img, binary=False) cv.imwrite(\u0026#39;encode.tif\u0026#39;,encoded) Setelah itu kita cek ukuran file setelah di encoding\nget_size(\u0026#39;encoded.tif\u0026#39;) 57.708984375 KB Hasilnya citra grayscale tersebut justru memiliki ukuran yang lebih besar daripada sebelum dilakukan encoding. Mari kita coba kita encoding citra tersebut kedalam citra binary.\nencoded_bin = RLE_encoding(img,binary=True) cv.imwrite(\u0026#39;encoded_bin.tif\u0026#39;,encoded_bin) get_size(\u0026#39;encoded_bin.tif\u0026#39;) 4.322265625 KB Hasilnya ketika dilakukan RLE pada citra binary ukuran file hasil kompresi jauh lebih kecil daripada citra asli.\nFungsi Decoding Untuk menampilkan kembali citra yang sudah diencoding perlu dilakukan decoding terlebih dahulu.\n# Fungsi untuk melakukan decoding def RLE_decode(encoded, shape): decoded=[] for rl in encoded: r,p = rl[0], rl[1] decoded.extend([p]*r) dimg = np.array(decoded).reshape(shape) return dimg decode = RLE_decode(encoded,img.shape) decode_bin = RLE_decode(encoded_bin,img.shape) show(decode,cmap=\u0026#34;gray\u0026#34;) show(decode_bin,cmap=\u0026#34;gray\u0026#34;)  Lena grayscale   Lena binary \nSimpulan Percobaan yang dilakukan ini mungkin memakan banyak waktu dan hasil yang diberikan tidak mengejutkan. Tapi kesimpulan yang dapat diambil dari percobaan ini adalah RLE (Run Length Encoding) dapat bekerja dengan baik dengan ketika:\n Citra yang akan diproses merupakan citra binary Frekuensi piksel pada citra tidak terlalu besar. Menyimpan dengan format TIFF.  Referensi\nGonzalez, Rafael C. 2001. Digital Image Processing Second Edition. Tom Robbins.\nEddine ALAA, Nour, dan Ismail Zine El Abidne. 2021. Introduction to Image Processing with Python. Cadi Ayyad University.\nViper, Quassarian. 2021. Image Compression In Python: Run Length Encoding. https://q-viper.github.io/2021/05/24/coding-run-length-encoding-in-python/ (diakses tanggal 15 Oktober 2021)\nHanifah, Riska. 2017. Image Compression. https://dosen.perbanas.id/image-compression/ (diakses tanggal 15 Oktober 2021)\n","date":"2021-10-14T18:05:40+07:00","image":"https://rizal-fd.github.io/p/rle-image-compression/background_hu0a29cb01f8c4e7973182e9356a3c7079_45339_120x120_fill_box_smart1_3.png","permalink":"https://rizal-fd.github.io/p/rle-image-compression/","title":"RLE Image compression"}]